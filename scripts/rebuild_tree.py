#!/usr/bin/env python3
"""
Script to rebuild folder tree structure from a JSON file generated by gather_tree.py.
"""

import argparse
import json
import logging
import sys
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Union, Any, Dict

try:
    from tqdm import tqdm
except ImportError:
    tqdm = None


@dataclass
class FileNode:
    """Represents a file node with name and type."""
    name: str
    type: str = "file"


@dataclass
class DirectoryNode:
    """Represents a directory node with name, type, and children."""
    name: str
    type: str = "folder"
    children: List[Union['FileNode', 'DirectoryNode']] = field(default_factory=list)


@dataclass
class TreeStructure:
    """Root structure containing the tree data."""
    root: DirectoryNode


def setup_logging(log_file: Path) -> None:
    """Set up logging to both console and file."""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler(sys.stdout)
        ]
    )


def dict_to_file_node(data: Dict[str, Any]) -> FileNode:
    """Convert dictionary to FileNode dataclass."""
    return FileNode(name=data['name'], type=data.get('type', 'file'))


def dict_to_directory_node(data: Dict[str, Any]) -> DirectoryNode:
    """Convert dictionary to DirectoryNode dataclass."""
    children: List[Union[FileNode, DirectoryNode]] = []
    for child_data in data.get('children', []):
        if child_data.get('type') == 'folder':
            children.append(dict_to_directory_node(child_data))
        else:
            children.append(dict_to_file_node(child_data))
    
    return DirectoryNode(
        name=data['name'],
        type=data.get('type', 'folder'),
        children=children
    )


def load_tree_from_json(json_path: Path) -> TreeStructure:
    """
    Load and parse JSON file, converting it to TreeStructure dataclass instances.
    
    Args:
        json_path: Path to JSON file generated by gather_tree.py
        
    Returns:
        TreeStructure containing the tree
        
    Raises:
        ValueError: If JSON file is invalid or doesn't match expected structure
        FileNotFoundError: If JSON file doesn't exist
        json.JSONDecodeError: If JSON parsing fails
    """
    if not json_path.exists():
        raise FileNotFoundError(f"JSON file does not exist: {json_path}")
    
    if not json_path.is_file():
        raise ValueError(f"Path is not a file: {json_path}")
    
    logging.info(f"Loading tree structure from: {json_path}")
    
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON file: {e}") from e
    
    if not isinstance(data, dict):
        raise ValueError("JSON root must be a dictionary")
    
    if 'root' not in data:
        raise ValueError("JSON must contain a 'root' key")
    
    root_data = data['root']
    if not isinstance(root_data, dict):
        raise ValueError("JSON root value must be a dictionary")
    
    if root_data.get('type') != 'folder':
        raise ValueError("JSON root must be a folder node")
    
    root = dict_to_directory_node(root_data)
    return TreeStructure(root=root)


def count_all_nodes(node: Union[FileNode, DirectoryNode]) -> int:
    """Count total number of nodes (files and directories) recursively."""
    if isinstance(node, DirectoryNode):
        count = 1  # Count this directory
        for child in node.children:
            count += count_all_nodes(child)
        return count
    else:
        return 1  # Count this file


def rebuild_directory(
    node: DirectoryNode,
    target_path: Path,
    progress_bar: Any = None
) -> None:
    """
    Recursively create directories and empty files from a DirectoryNode.
    
    Args:
        node: DirectoryNode to rebuild
        target_path: Path where the directory should be created
        progress_bar: Optional tqdm progress bar
        
    Raises:
        FileExistsError: If target path already exists (fail-fast)
        OSError: If directory cannot be created
    """
    dir_path = target_path / node.name
    
    # Fail-fast: check if path already exists
    if dir_path.exists():
        raise FileExistsError(
            f"Directory already exists at target path: {dir_path}"
        )
    
    # Create directory
    try:
        dir_path.mkdir(parents=False, exist_ok=False)
        logging.debug(f"Created directory: {dir_path}")
        if progress_bar:
            progress_bar.update(1)
    except OSError as e:
        raise OSError(f"Could not create directory {dir_path}: {e}") from e
    
    # Process children
    for child in node.children:
        child_path = dir_path / child.name
        
        # Fail-fast: check if path already exists
        if child_path.exists():
            raise FileExistsError(
                f"Path already exists at target: {child_path}"
            )
        
        if isinstance(child, DirectoryNode):
            # Recursively rebuild subdirectory
            rebuild_directory(child, dir_path, progress_bar)
        else:
            # Create empty file
            try:
                child_path.touch()
                logging.debug(f"Created file: {child_path}")
                if progress_bar:
                    progress_bar.update(1)
            except OSError as e:
                raise OSError(f"Could not create file {child_path}: {e}") from e


def rebuild_tree(tree: TreeStructure, target_path: Path) -> None:
    """
    Rebuild the entire tree structure from TreeStructure.
    
    Args:
        tree: TreeStructure to rebuild
        target_path: Directory where the root directory should be created
        
    Raises:
        ValueError: If target_path is invalid
        FileExistsError: If root directory already exists (fail-fast)
        OSError: If filesystem operations fail
    """
    if not target_path.exists():
        raise ValueError(f"Target directory does not exist: {target_path}")
    
    if not target_path.is_dir():
        raise ValueError(f"Target path is not a directory: {target_path}")
    
    # Root directory will be created at target_path / tree.root.name
    root_path = target_path / tree.root.name
    
    # Fail-fast: check if root directory already exists
    if root_path.exists():
        raise FileExistsError(
            f"Root directory already exists at target: {root_path}"
        )
    
    logging.info(f"Rebuilding tree structure at: {root_path}")
    
    # Count total nodes for progress bar
    total_nodes = count_all_nodes(tree.root)
    use_progress = total_nodes > 100  # Use progress bar for large trees
    
    # Rebuild tree with optional progress bar
    if use_progress and tqdm:
        with tqdm(total=total_nodes, desc="Rebuilding tree", unit="item") as pbar:
            rebuild_directory(tree.root, target_path, pbar)
    else:
        rebuild_directory(tree.root, target_path, None)
    
    logging.info("Tree structure rebuilt successfully")


def print_report(json_path: Path, target_path: Path, tree: TreeStructure) -> None:
    """Print a concise execution report."""
    def count_nodes(node: Union[FileNode, DirectoryNode]) -> tuple[int, int]:
        """Count files and directories recursively."""
        if isinstance(node, DirectoryNode):
            files, dirs = 0, 1
            for child in node.children:
                f, d = count_nodes(child)
                files += f
                dirs += d
            return (files, dirs)
        else:
            return (1, 0)
    
    files, dirs = count_nodes(tree.root)
    
    print("\n" + "="*60)
    print("Execution Report")
    print("="*60)
    print(f"Source JSON: {json_path}")
    print(f"Target directory: {target_path}")
    print(f"Total files created: {files}")
    print(f"Total directories created: {dirs}")
    print(f"Total items: {files + dirs}")
    print("="*60)


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Rebuild folder tree structure from a JSON file generated by gather_tree.py"
    )
    parser.add_argument(
        "json_path",
        type=str,
        help="Path to JSON file generated by gather_tree.py"
    )
    parser.add_argument(
        "target_path",
        type=str,
        help="Directory where the tree structure should be rebuilt"
    )
    
    args = parser.parse_args()
    
    json_path = Path(args.json_path)
    target_path = Path(args.target_path)
    
    # Set up logging
    # Create log file in the same directory as JSON file, or current directory if JSON parent doesn't exist
    if json_path.parent.exists():
        log_file = json_path.parent / f"{json_path.stem}_rebuild.log"
    else:
        log_file = Path.cwd() / f"{json_path.stem}_rebuild.log"
    setup_logging(log_file)
    
    try:
        # Load tree structure from JSON
        start_time = time.time()
        
        tree = load_tree_from_json(json_path)
        
        # Rebuild tree structure
        rebuild_tree(tree, target_path)
        
        elapsed_time = time.time() - start_time
        
        # Print report
        print_report(json_path, target_path, tree)
        
        logging.info(f"Script completed successfully in {elapsed_time:.2f} seconds")
        return 0
    
    except FileNotFoundError as e:
        logging.error(f"File not found: {e}")
        return 1
    except ValueError as e:
        logging.error(f"Invalid input: {e}")
        return 1
    except FileExistsError as e:
        logging.error(f"Path already exists (fail-fast): {e}")
        return 1
    except OSError as e:
        logging.error(f"OS error: {e}")
        return 1
    except Exception as e:
        logging.exception(f"Unexpected error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())

